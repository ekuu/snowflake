// Code generated by "gogen option -n Node -s node,nodeBits,globalFlag,storage,epoch --with-error --with-init -p _"; DO NOT EDIT.

package snowflake

import (
	"fmt"
	"time"
)

// New constructor
func New(_opts ...Option) (*Node, error) {
	_n := new(Node)

	_n.SetOptions(_opts...)

	if err := _n.init(); err != nil {
		return nil, err
	}
	return _n, nil
}

// MustNew must constructor, it will panic if error not nil
func MustNew(_opts ...Option) *Node {
	_n, err := New(_opts...)
	if err != nil {
		panic(err)
	}
	return _n
}

// Option option interface
type Option interface {
	apply(*Node)
}

// Option option function
type optionFunc func(*Node)

func (f optionFunc) apply(_n *Node) {
	f(_n)
}

func (_n *Node) SetOptions(_opts ...Option) *Node {
	for _, _opt := range _opts {
		_opt.apply(_n)
	}
	return _n
}

func SkipOption() Option {
	return optionFunc(func(_n *Node) {
		return
	})
}

func WithOptions(o *options) Option {
	return optionFunc(func(_n *Node) {
		_n.SetOptions(o.opts...)
	})
}

// options options struct
type options struct {
	opts []Option
}

// NewOptions new options struct
func NewOptions() *options {
	return new(options)
}

func (_o *options) Options() []Option {
	return _o.opts
}

func (_o *options) Append(_opts ...Option) *options {
	_o.opts = append(_o.opts, _opts...)
	return _o
}

// Storage storage option of Node
func (_o *options) Storage(storage Storage) *options {
	_o.opts = append(_o.opts, WithStorage(storage))
	return _o
}

// Epoch epoch option of Node
func (_o *options) Epoch(epoch time.Time) *options {
	_o.opts = append(_o.opts, WithEpoch(epoch))
	return _o
}

// GlobalFlag globalFlag option of Node
func (_o *options) GlobalFlag(globalFlag bool) *options {
	_o.opts = append(_o.opts, WithGlobalFlag(globalFlag))
	return _o
}

// Node node option of Node
func (_o *options) Node(node uint64) *options {
	_o.opts = append(_o.opts, WithNode(node))
	return _o
}

// NodeBits nodeBits option of Node
func (_o *options) NodeBits(nodeBits uint8) *options {
	_o.opts = append(_o.opts, WithNodeBits(nodeBits))
	return _o
}

// WithStorage storage option of Node
func WithStorage(storage Storage) Option {
	return optionFunc(func(_n *Node) {
		_n.storage = storage
	})
}

// WithEpoch epoch option of Node
func WithEpoch(epoch time.Time) Option {
	return optionFunc(func(_n *Node) {
		_n.epoch = epoch
	})
}

// WithGlobalFlag globalFlag option of Node
func WithGlobalFlag(globalFlag bool) Option {
	return optionFunc(func(_n *Node) {
		_n.globalFlag = globalFlag
	})
}

// WithNode node option of Node
func WithNode(node uint64) Option {
	return optionFunc(func(_n *Node) {
		_n.node = node
	})
}

// WithNodeBits nodeBits option of Node
func WithNodeBits(nodeBits uint8) Option {
	return optionFunc(func(_n *Node) {
		_n.nodeBits = nodeBits
	})
}

func PrintOptions(packageName string) {
	opts := []string{
		"WithStorage()",
		"WithEpoch()",
		"WithGlobalFlag()",
		"WithNode()",
		"WithNodeBits()",
	}
	if packageName == "" {
		fmt.Printf("opts := []Option{ \n")
		for _, v := range opts {
			fmt.Printf("	%s,\n", v)
		}
	} else {
		fmt.Printf("opts := []%s.Option{ \n", packageName)
		for _, v := range opts {
			fmt.Printf("	%s.%s,\n", packageName, v)
		}
	}
	fmt.Println("}")
}
